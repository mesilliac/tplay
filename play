#!/usr/bin/env python
"""usage:
$ play [song] [options]
    or
>>> from play import play
>>> play(song,**options)
"""
from __future__ import division, print_function
import math
import Nsound
# setup
samplerate = 44100 # per second
nchannels = 2 # per sample
bits = 16 # per channel?
clipping_freq = 16.0
sine = Nsound.Sine(samplerate)
# playback
out = Nsound.AudioStream(samplerate,nchannels)
playback = Nsound.AudioPlayback(samplerate,nchannels,bits)
# instruments
bass = Nsound.GuitarBass(samplerate)
organ = Nsound.OrganPipe(samplerate) # requires dual channel output
clarinet = Nsound.Clarinet(samplerate)
kicker = Nsound.DrumKickBass(samplerate,1000,40)
bd01 = Nsound.DrumBD01(samplerate)
hat = Nsound.Hat(samplerate)
flute = Nsound.FluteSlide(samplerate)

# parse command line arguments for use as function arguments
def parse_argv_for(function):
    from sys import argv
    import json
    f = function.func_code
    defaults = function.func_defaults
    nargs = f.co_argcount
    args = []
    kwargs = {}
    for n in range(nargs):
        name = f.co_varnames[n]
        m = n + len(defaults) - nargs
        if m < 0: # has no default value
            # obtain from argv
            try: args.append(argv[n+1])
            except IndexError: args.append(None)
        else: # has a default value
            value = defaults[m]
            if len(argv) > 1+n and not argv[1+n].startswith('--'):
                value = argv[1+n]
                kwargs[name] = value
            for arg in argv[1:]: # not the most efficient
                if arg.startswith('--'+name):
                    if '=' in arg:
                        value = arg.split('=')[1]
                        try: value = json.loads(value)
                        except ValueError: pass
                    else: value = True
            kwargs[name] = value
            if value == defaults[m]: kwargs.pop(name) # don't bother transmitting defaults
    return args,kwargs

# parse and play from command line
def play_from_command_line():
    args, kwargs = parse_argv_for(play)
    if args: print(args)
    if kwargs: print(kwargs)
    play(*args,**kwargs)

# get note by name
def get_note(name):
    # (note)(octave) = (a4)*2**(octave-4)*2**(note-(a))
    name = name.lower()
    note = 'c d ef g a b'.find(name[0]) # sharps and flats parsed below
    if note < 0: raise ValueError('unparsable note name', name)
    sharp = 0 # semitones higher
    if name[1] in '#s': sharp = +1
    elif name[1] in 'bf': sharp = -1
    octave = int(name[1+abs(sharp):])
    a4 = 440 # 440Hz = concert pitch A4
    a = 9 # 'c d ef g a b'.find('a')
    return a4*2**((octave-4)+(note+sharp-a)/12)

# song characters
song_characters = {
    '0123345678~+*-_. ': 'data',
    '()[]': 'tempo',
    '{}': 'structure',
    'abcdefgABCDEFG#bsf': 'names',
    'tTrRmM\n': 'other'}

# play a song
def play(song=None,
         root='a1', mode='major', bpm=100, loop=False, transpose=0, swing=False):
    play_from_stdin = not song # if no song, play lines from stdin
    if play_from_stdin: # set stdin to non-blocking and set song to default
        import sys, os, fcntl
        fcntl.fcntl(sys.stdin,fcntl.F_SETFL,os.O_NONBLOCK)
        song = '0'
    spb = 60/float(bpm) # seconds per beat
    if swing: spb *= 2/3
    transpose = 2**(float(transpose)/12) # transpose by semitones
    loop = int(loop)
    if loop == 1: loop = -1 # infinite loopings
    elif loop == 0: loop = +1 # play once
    sine.silence(spb*1) >> playback
    try: root = float(root) # Hz?
    except ValueError: root = get_note(root) # name
    # Scale: a semi-imaginary scale. based on real scales, honest.
    class Scale: pass
    Scale.__init__ = lambda x,scale: setattr(x,'real',scale)
    Scale.__getitem__ = lambda x,a: x.real[a%len(x.real)]*2**(a//len(x.real))
    t = lambda a,b: a*2**(b/12)
    major_scale = Scale([root,t(root,2),t(root,4),t(root,5),t(root,7),t(root,9),t(root,11)])
    minor_scale = Scale([root,t(root,2),t(root,3),t(root,5),t(root,7),t(root,8),t(root,10)])
    if mode == 'minor': scale = minor_scale
    else: scale = major_scale
    # TODO: remove. need to work out how to sustain notes without clipping and without readahead.
    def get_note_length(playhead,swing_offset=0):
        duration = 1
        beat_count = swing_offset
        if swing and not beat_count % 2: duration += 1
        while playhead < len(song)-1:
            playhead += 1
            char = song[playhead]
            if char == '~' or char.isspace():
                duration += 1
                beat_count += 1
                if swing and not beat_count % 2: duration += 1
            else: break
        return duration
    playhead = -1
    meta = 0
    rotate = 0
    try:
        while playhead < len(song):
            playhead += 1
            if not playhead:
                note = None
                beat_count = 0
                spb = 60/float(bpm)
                if swing: spb *= 2/3
            # if new line from stdin then start playing that
            if play_from_stdin:
                try: new_song = sys.stdin.readline()
                except IOError: new_song = None
                if new_song:
                    playhead = -1
                    if new_song.strip('\n'): song = new_song.strip('\n')
                    continue
            if playhead == len(song):
                loop -= 1
                if loop: playhead = -1; continue
                else: break
            char = song[playhead]
            #print(char,end='')
            if not filter(None,(char in x for x in song_characters)):
                raise Exception("unrecognized character '%s'" % char)
            if char == 'T': playhead += 1; transpose *= 2**(int(song[playhead])/12); continue
            elif char == 't': playhead += 1; transpose /= 2**(int(song[playhead])/12); continue
            elif char == 'R': playhead += 1; rotate += int(song[playhead]); continue
            elif char == 'r': playhead += 1; rotate -= int(song[playhead]); continue
            elif char == 'M': scale = major_scale; continue
            elif char == 'm': scale = minor_scale; continue
            elif char == '{': meta += 1; continue
            elif char == '}': meta -= 1; continue
            elif char == '[': spb /= 2; continue
            elif char == ']': spb *= 2; continue
            elif char == '(': spb *= 2; continue
            elif char == ')': spb /= 2; continue
            elif char.isspace(): beat_count += 1; continue # do whatever
            elif char == '~': beat_count += 1; continue # sustain note
            elif char == '.': beat_count += 1; note = (spb, 0);
            elif char == '#': note = (spb*get_note_length(playhead,beat_count%2),note[1]*2**(1/12)); beat_count += 1
            elif char == 'b': note = (spb*get_note_length(playhead,beat_count%2),note[1]*2**(-1/12)); beat_count += 1
            elif char.isdigit(): # new note
                if char == '0': freq = root*2**(-5/12)
                else: freq = scale[int(char)+rotate-1]
                if transpose: freq *= transpose
                length = get_note_length(playhead,beat_count%2)
                beat_count += 1
                note = (spb*length, freq)
            if play_from_stdin: sys.stdout.flush()
            if note[1]: bass.play(*note).__div__(math.log(note[1]/clipping_freq,2)) >> playback
            else: sine.silence(note[0]) >> playback
    except KeyboardInterrupt: print("...ciao")

# if running standalone
if __name__ == "__main__": play_from_command_line()

