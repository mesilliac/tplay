#!/usr/bin/env python
"""usage:
$ play [song] [options]
    or
>>> from play import play
>>> play(song,**options)
"""
from __future__ import division
import math
import Nsound
# setup
samplerate = 44100 # per second
nchannels = 2 # per sample
bits = 16 # per channel?
clipping_freq = 16.0
sine = Nsound.Sine(samplerate)
# playback
out = Nsound.AudioStream(samplerate,nchannels)
playback = Nsound.AudioPlayback(samplerate,nchannels,bits)
# instruments
bass = Nsound.GuitarBass(samplerate)
organ = Nsound.OrganPipe(samplerate) # requires dual channel output
clarinet = Nsound.Clarinet(samplerate)
kicker = Nsound.DrumKickBass(samplerate,1000,40)
bd01 = Nsound.DrumBD01(samplerate)
hat = Nsound.Hat(samplerate)
flute = Nsound.FluteSlide(samplerate)

# parse command line arguments for use as function arguments
def parse_argv_for(function):
    from sys import argv
    import json
    f = function.func_code
    defaults = function.func_defaults
    nargs = f.co_argcount
    args = []
    kwargs = {}
    for n in range(nargs):
        name = f.co_varnames[n]
        m = n + len(defaults) - nargs
        if m < 0: # has no default value
            # obtain from argv
            try: args.append(argv[n+1])
            except IndexError: args.append(None)
        else: # has a default value
            value = defaults[m]
            if len(argv) > 1+n and not argv[1+n].startswith('--'):
                value = argv[1+n]
                kwargs[name] = value
            for arg in argv[1:]:
                if arg.startswith('--'+name):
                    if '=' in arg:
                        value = arg.split('=')[1]
                        try: value = json.loads(value)
                        except ValueError: pass
                    else: value = True
            kwargs[name]=value
    return args,kwargs

# parse and play from command line
def play_from_command_line():
    args, kwargs = parse_argv_for(play)
    print(args)
    print(kwargs)
    play(*args,**kwargs)

# get note by name
def get_note(name):
    # (note)(octave) = (a4)*2**(octave-4)*2**(note-(a))
    name = name.lower()
    note = 'c d ef g a b'.find(name[0]) # sharps and flats parsed below
    if note < 0: raise ValueError('unparsable note name', name)
    sharp = 0 # semitones higher
    if name[1] in '#s': sharp = +1
    elif name[1] in 'bf': sharp = -1
    octave = int(name[1+abs(sharp):])
    a4 = 440 # 440Hz = concert pitch A4
    a = 9 # 'c d ef g a b'.find('a')
    return a4*2**((octave-4)+(note+sharp-a)/12)

# play a song
def play(song="156[5678]56[5678]56[532~~~][.532]",
              root='a1', mode='major', bpm=100, loop=False, transpose=0, swing=False):
    spb = 60/float(bpm) # seconds per beat
    if swing: spb *= 2/3
    transpose = 2**(float(transpose)/12) # transpose by semitones
    loop = int(loop)
    if loop == 1: loop = -1 # infinite loopings
    elif loop == 0: loop = +1 # play once
    sine.silence(spb*1) >> playback
    t = lambda a,b: a*2**(b/12)
    try:
        root = float(root) # Hz?
    except ValueError:
        root = get_note(root) # name
    # Scale: a semi-imaginary scale. based on real scales, honest.
    class Scale: pass
    Scale.__init__ = lambda x,scale: setattr(x,'real',scale)
    Scale.__getitem__ = lambda x,a: x.real[a%len(x.real)]*2**(a//len(x.real))
    major_scale = Scale([root,t(root,2),t(root,4),t(root,5),t(root,7),t(root,9),t(root,11)])
    minor_scale = Scale([root,t(root,2),t(root,3),t(root,5),t(root,7),t(root,8),t(root,10)])
    if mode == 'minor': scale = minor_scale
    else: scale = major_scale
    def get_note_length(playhead,swing_offset=0):
        duration = 1
        beat_count = swing_offset
        if swing and not beat_count % 2: duration += 1
        while playhead < len(song)-1:
            playhead += 1
            char = song[playhead]
            if char == '~' or char.isspace():
                duration += 1
                beat_count += 1
                if swing and not beat_count % 2: duration += 1
            else: break
        return duration
    def get_number(playhead):
        sign = +1
        digits = []
        while playhead < len(song)-1 and not song[playhead] == '}':
            playhead += 1
            c = song[playhead]
            if c.isdigit(): digits.append(c)
            elif digits: break
            elif c == '-': sign = -1
            elif c == '+': sign = +1
            else: digits.append('0'); break # or something
        return int(''.join(digits))*sign
    note = None
    playhead = -1
    metadata = False
    beat_count = 0
    rotate = 0
    try:
        while playhead < len(song):
            playhead += 1
            #print playhead,
            if playhead == len(song):
                loop -= 1
                if loop: playhead = -1; continue
                else: break
            char = song[playhead]
            if metadata: # parse metadata
                if char == 't': transpose *= 2**(get_number(playhead)/12)
                elif char == 'r': rotate += get_number(playhead)
                elif char == '}': metadata = False
                else: pass
                continue
            elif char.isdigit(): # new note
                if char == '0': freq = root*2**(-5/12)
                else: freq = scale[int(char)+rotate-1]
                if transpose: freq *= transpose
                length = get_note_length(playhead,beat_count%2)
                beat_count += 1
                note = (spb*length, freq)
            elif char.isspace(): beat_count += 1; continue # do whatever
            elif char == '~': beat_count += 1; continue # sustain note
            elif char == '.': note = (spb, 0); beat_count += 1;
            elif char == '[': spb /= 2; continue
            elif char == ']': spb *= 2; continue
            elif char == '(': spb *= 2; continue
            elif char == ')': spb /= 2; continue
            elif char == '{': metadata = True; continue
            elif char == '#': note = (spb*get_note_length(playhead,beat_count%2),note[1]*2**(1/12)); beat_count += 1
            elif char == 'b': note = (spb*get_note_length(playhead,beat_count%2),note[1]*2**(-1/12)); beat_count += 1
            elif char == 'm': scale = minor_scale; continue
            elif char == 'M': scale = major_scale; continue
            else: raise Exception("unrecognized character '%s'" % char)
            #print(note)
            if note[1]: bass.play(*note).__div__(math.log(note[1]/clipping_freq,2)) >> playback
            else: sine.silence(note[0]) >> playback
    except KeyboardInterrupt: print("...ciao")

# if running standalone
if __name__ == "__main__": play_from_command_line()

